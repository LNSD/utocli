//! # utocli-clap
//!
//! Clap derive integration for utocli - generate OpenCLI specifications from clap Parser types.
//!
//! This crate provides proc macros that work seamlessly with clap's derive macros,
//! allowing you to define your CLI once and automatically generate OpenCLI specs.
//!
//! # Design Principles
//!
//! - **Clap First**: Clap types and attributes are the primary source of truth
//! - **Non-Invasive**: Adding OpenCLI support doesn't change clap functionality
//! - **Composable**: `#[opencli(...)]` attributes augment, don't replace clap attributes
//! - **Single Source of Truth**: CLI structure defined once in clap types
//!
//! # Example
//!
//! ```ignore
//! use clap::{Parser, Subcommand};
//! use utocli_clap::OpenCli;
//!
//! #[derive(Parser, OpenCli)]
//! #[command(name = "mycli", version = "1.0.0", about = "My CLI")]
//! #[opencli(info(title = "My CLI Tool"))]
//! struct Cli {
//!     #[arg(short, long)]
//!     verbose: bool,
//!
//!     #[command(subcommand)]
//!     command: Commands,
//! }
//!
//! #[derive(Subcommand, CommandCollection)]
//! enum Commands {
//!     /// Say hello
//!     Hello { name: String },
//! }
//!
//! fn main() {
//!     let cli = Cli::parse();  // Use clap normally
//!     let spec = Cli::opencli();  // Generate OpenCLI spec
//! }
//! ```

use proc_macro::TokenStream;
use quote::ToTokens;
use syn::{DeriveInput, parse_macro_input};

mod arg;
mod args;
mod diagnostics;
mod mapping;
mod parser;
mod subcommand;

/// Derive macro for generating OpenCLI specifications from clap Parser types.
///
/// This macro works with clap's `#[derive(Parser)]` to automatically generate
/// OpenCLI specifications from your CLI definition.
///
/// # Example
///
/// ```ignore
/// use clap::Parser;
/// use utocli_clap::OpenCli;
///
/// #[derive(Parser, OpenCli)]
/// #[command(name = "mycli", version = "1.0.0")]
/// #[opencli(info(title = "My CLI Tool"))]
/// struct Cli {
///     #[arg(short, long)]
///     verbose: bool,
/// }
///
/// fn main() {
///     let spec = Cli::opencli();  // Generated by this macro
/// }
/// ```
///
/// # Attributes
///
/// ## `#[opencli(...)]` on Parser struct
///
/// * `info(...)` - Application metadata (title, contact, license, etc.)
/// * `operation_id = "..."` - Unique operation identifier for root command
/// * `aliases(...)` - Command aliases
/// * `tags(...)` - Tags for categorization
/// * `external_docs(...)` - External documentation
///
/// ## `#[opencli(...)]` on fields
///
/// * `scope = "inherited"|"local"` - Parameter scope (overrides inferred from `global`)
/// * `format = "path"|"email"|...` - Schema format hint
/// * `example = "..."` - Example value
/// * `description = "..."` - Override field description
///
/// # Requirements
///
/// * Must be used with `#[derive(Parser)]` from clap
/// * Struct must have named fields
#[proc_macro_derive(OpenCli, attributes(opencli, command, arg))]
pub fn derive_opencli(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    // Generate OpenCli implementation
    // Note: We don't validate that Parser is present because proc macros
    // execute in order and can't see other derives in the same list.
    // If Parser is missing, the generated code will fail to compile with
    // clear errors about missing clap types.
    match parser::generate_opencli(&input) {
        Ok(tokens) => tokens.into(),
        Err(diagnostics) => diagnostics.to_token_stream().into(),
    }
}

/// Derive macro for generating CommandCollection from clap Subcommand enums.
///
/// This macro works with clap's `#[derive(Subcommand)]` to automatically generate
/// a collection of OpenCLI commands from the enum variants.
///
/// # Example
///
/// ```ignore
/// use clap::Subcommand;
/// use utocli_clap::CommandCollection;
///
/// #[derive(Subcommand, CommandCollection)]
/// enum Commands {
///     /// Validate a file
///     #[opencli(operation_id = "validateCommand")]
///     Validate {
///         file: String,
///     },
///     /// Generate code
///     Generate {
///         output: String,
///     },
/// }
/// ```
///
/// # Attributes
///
/// ## `#[opencli(...)]` on variants
///
/// * `operation_id = "..."` - Unique operation identifier
/// * `aliases(...)` - Command aliases
/// * `tags(...)` - Tags for categorization
/// * `deprecated` - Mark command as deprecated
///
/// # Requirements
///
/// * Must be used with `#[derive(Subcommand)]` from clap
/// * Enum must have named or unnamed fields (unit variants not supported yet)
#[proc_macro_derive(CommandCollection, attributes(opencli, command, arg))]
pub fn derive_command_collection(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    // Generate CommandCollection implementation
    // Note: We don't validate that Subcommand is present because proc macros
    // execute in order and can't see other derives in the same list.
    // If Subcommand is missing, the generated code will fail to compile with
    // clear errors about missing clap types.
    match subcommand::generate_command_collection(&input) {
        Ok(tokens) => tokens.into(),
        Err(diagnostics) => diagnostics.to_token_stream().into(),
    }
}
